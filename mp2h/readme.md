### ECE 220 Honors Section
# MP2 - Parallel Accumulator with Shared Total

In this MP you will implement a parallel accumulator that calculates the sum of all numbers within a set of given files. The difference between the first and MP and the second MP is where the result is stored. In MP1 the result is stored in an array of size `NUM_THREADS`, while in this MP there is only a single variable to store the result.

### General guidelines: 
1. You can vary the number of threads by calling `generate_data.py` with different arguments
2. Do not change `thread_info.h` as this file is automatically generated by `generate_data.py`
3. `thread_info.h` will hold a global variable `NUM_THREADS` which you can use in your program
3. Do not change any of the python (.py) files

---
### Usage:  

  1. generate 1,000,000 input data points separated in <number_of_threads> [1-99] files  
    
    $ python3 generate_data.py [number_of_threads]
  
  For example, try starting with:

    $ python3 generate_data.py 4
    
  2. compile program
    
    $ gcc acc_serial.c -g -o acc_serial
    $ gcc acc_parallel.c -g -lpthread -o acc_parallel

  3. run test program

    $ ./acc_serial
    $ ./acc_parallel

  4. automatically recompile and run both versions of the accumulator, compares the output and speedup

    $ python3 benchmark.py

  5. make a graph of speedup vs number of threads used (requires matplotlib)

    $ python3 graph.py

---
### Programming Tasks:
1. Complete the pthread wrapper function parallel_acc_wrapper in acc.h  
2. Complete the sequential version of the accumulator in acc_serial.c  
3. Complete the parallel version of the accumulator in acc_parallel.c
4. Verify the two outputs for serial_output.txt and parallel_output.txt are the same.

### Report:
In your report answer the following questions and submit on Gradescope:

  1. If we don't use a mutex in acc.h to guard result, we could see that running `acc_parallel` multiple times could give you inconsistent results. Why?

  2. Include console output from running `python benchmark.py` with number_of_threads being 8.

  3. Include and compare graphs generated by `python graph.py` by both MP1 and MP2. Which solution is better and why?

  4. You are writing a program that contains three threads.  The following threads are labled *S1*, *S2*, *S3* and use the locking method shown below. Do you see a potential problem? If there is a problem, define the problem and describe it.
     
  <!-- ![HomeworkProblem](./images/Problem2.5.4.png?raw=true) -->
  <p align="center">
    <img src="./images/Problem2.5.4.png?raw=true" alt="question4image" width="300"/>
  </p>

---
##### End MP2H


